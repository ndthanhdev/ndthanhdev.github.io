// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"os"

	"github.com/vektah/gqlparser/v2/gqlerror"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.25.0"
	"go.opentelemetry.io/otel/trace"

	"dagger/ndthanhdev-github-io/internal/dagger"
	"dagger/ndthanhdev-github-io/internal/querybuilder"
	"dagger/ndthanhdev-github-io/internal/telemetry"
)

var dag = dagger.Connect()

func Tracer() trace.Tracer {
	return otel.Tracer("dagger.io/sdk.go")
}

// used for local MarshalJSON implementations
var marshalCtx = context.Background()

// called by main()
func setMarshalContext(ctx context.Context) {
	marshalCtx = ctx
	dagger.SetMarshalContext(ctx)
}

type DaggerObject = querybuilder.GraphQLMarshaller

type ExecError = dagger.ExecError

// ptr returns a pointer to the given value.
func ptr[T any](v T) *T {
	return &v
}

// convertSlice converts a slice of one type to a slice of another type using a
// converter function
func convertSlice[I any, O any](in []I, f func(I) O) []O {
	out := make([]O, len(in))
	for i, v := range in {
		out[i] = f(v)
	}
	return out
}

func (r NdthanhdevGithubIo) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Dir     *any
		Mode    string
		GhToken *any
	}
	concrete.Dir = r.Dir
	concrete.Mode = r.Mode
	concrete.GhToken = r.GhToken
	return json.Marshal(&concrete)
}

func (r *NdthanhdevGithubIo) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Dir     *any
		Mode    string
		GhToken *any
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Dir = concrete.Dir
	r.Mode = concrete.Mode
	r.GhToken = concrete.GhToken
	return nil
}

func main() {
	ctx := context.Background()

	// Direct slog to the new stderr. This is only for dev time debugging, and
	// runtime errors/warnings.
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slog.LevelWarn,
	})))

	if err := dispatch(ctx); err != nil {
		os.Exit(2)
	}
}

func unwrapError(rerr error) string {
	var gqlErr *gqlerror.Error
	if errors.As(rerr, &gqlErr) {
		return gqlErr.Message
	}
	return rerr.Error()
}

func dispatch(ctx context.Context) (rerr error) {
	ctx = telemetry.InitEmbedded(ctx, resource.NewWithAttributes(
		semconv.SchemaURL,
		semconv.ServiceNameKey.String("dagger-go-sdk"),
		// TODO version?
	))
	defer telemetry.Close()

	// A lot of the "work" actually happens when we're marshalling the return
	// value, which entails getting object IDs, which happens in MarshalJSON,
	// which has no ctx argument, so we use this lovely global variable.
	setMarshalContext(ctx)

	fnCall := dag.CurrentFunctionCall()
	defer func() {
		if rerr != nil {
			if err := fnCall.ReturnError(ctx, dag.Error(unwrapError(rerr))); err != nil {
				fmt.Println("failed to return error:", err)
			}
		}
	}()

	parentName, err := fnCall.ParentName(ctx)
	if err != nil {
		return fmt.Errorf("get parent name: %w", err)
	}
	fnName, err := fnCall.Name(ctx)
	if err != nil {
		return fmt.Errorf("get fn name: %w", err)
	}
	parentJson, err := fnCall.Parent(ctx)
	if err != nil {
		return fmt.Errorf("get fn parent: %w", err)
	}
	fnArgs, err := fnCall.InputArgs(ctx)
	if err != nil {
		return fmt.Errorf("get fn args: %w", err)
	}

	inputArgs := map[string][]byte{}
	for _, fnArg := range fnArgs {
		argName, err := fnArg.Name(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg name: %w", err)
		}
		argValue, err := fnArg.Value(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg value: %w", err)
		}
		inputArgs[argName] = []byte(argValue)
	}

	result, err := invoke(ctx, []byte(parentJson), parentName, fnName, inputArgs)
	if err != nil {
		var exec *dagger.ExecError
		if errors.As(err, &exec) {
			return exec.Unwrap()
		}
		return err
	}
	resultBytes, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("marshal: %w", err)
	}

	if err := fnCall.ReturnValue(ctx, dagger.JSON(resultBytes)); err != nil {
		return fmt.Errorf("store return value: %w", err)
	}
	return nil
}
func invoke(ctx context.Context, parentJSON []byte, parentName string, fnName string, inputArgs map[string][]byte) (_ any, err error) {
	_ = inputArgs
	switch parentName {
	case "NdthanhdevGithubIo":
		switch fnName {
		case "MoonRun":
			var parent NdthanhdevGithubIo
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var command string
			if inputArgs["command"] != nil {
				err = json.Unmarshal([]byte(inputArgs["command"]), &command)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg command", err))
				}
			}
			return (*NdthanhdevGithubIo).MoonRun(&parent, ctx, command), nil
		case "Test":
			var parent NdthanhdevGithubIo
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*NdthanhdevGithubIo).Test(&parent, ctx)
		case "Build":
			var parent NdthanhdevGithubIo
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*NdthanhdevGithubIo).Build(&parent, ctx), nil
		case "Publish":
			var parent NdthanhdevGithubIo
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*NdthanhdevGithubIo).Publish(&parent, ctx)
		case "":
			var parent NdthanhdevGithubIo
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var dir *any
			if inputArgs["dir"] != nil {
				err = json.Unmarshal([]byte(inputArgs["dir"]), &dir)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg dir", err))
				}
			}
			var mode string
			if inputArgs["mode"] != nil {
				err = json.Unmarshal([]byte(inputArgs["mode"]), &mode)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg mode", err))
				}
			}
			var ghToken *any
			if inputArgs["ghToken"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ghToken"]), &ghToken)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ghToken", err))
				}
			}
			return New(dir, mode, ghToken), nil
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "":
		return dag.Module().
			WithDescription("A generated module for NdthanhdevGithubIo functions\n\nThis module has been generated via dagger init and serves as a reference to\nbasic module structure as you get started with Dagger.\n\nTwo functions have been pre-created. You can modify, delete, or add to them,\nas needed. They demonstrate usage of arguments and return types using simple\necho and grep commands. The functions can be called from the dagger CLI or\nfrom one of the SDKs.\n\nThe first line in this comment block is a short description line and the\nrest is a long description with more detail on the module's purpose or usage,\nif appropriate. All modules should have a short description.\n").
			WithObject(
				dag.TypeDef().WithObject("NdthanhdevGithubIo", dagger.TypeDefWithObjectOpts{SourceMap: dag.SourceMap("main.go", 21, 6)}).
					WithFunction(
						dag.Function("MoonRun",
							dag.TypeDef().WithKind(dagger.TypeDefKindVoidKind).WithOptional(true)).
							WithSourceMap(dag.SourceMap("main.go", 79, 1)).
							WithArg("command", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 79, 59)})).
					WithFunction(
						dag.Function("Test",
							dag.TypeDef().WithKind(dagger.TypeDefKindStringKind)).
							WithSourceMap(dag.SourceMap("main.go", 86, 1))).
					WithFunction(
						dag.Function("Build",
							dag.TypeDef().WithKind(dagger.TypeDefKindVoidKind).WithOptional(true)).
							WithSourceMap(dag.SourceMap("main.go", 92, 1))).
					WithFunction(
						dag.Function("Publish",
							dag.TypeDef().WithKind(dagger.TypeDefKindStringKind)).
							WithSourceMap(dag.SourceMap("main.go", 98, 1))).
					WithField("Dir", dag.TypeDef().WithKind(dagger.TypeDefKindVoidKind).WithOptional(true), dagger.TypeDefWithFieldOpts{SourceMap: dag.SourceMap("main.go", 22, 2)}).
					WithField("Mode", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.TypeDefWithFieldOpts{SourceMap: dag.SourceMap("main.go", 23, 2)}).
					WithField("GhToken", dag.TypeDef().WithKind(dagger.TypeDefKindVoidKind).WithOptional(true), dagger.TypeDefWithFieldOpts{SourceMap: dag.SourceMap("main.go", 24, 2)}).
					WithConstructor(
						dag.Function("New",
							dag.TypeDef().WithObject("NdthanhdevGithubIo")).
							WithSourceMap(dag.SourceMap("main.go", 27, 1)).
							WithArg("dir", dag.TypeDef().WithKind(dagger.TypeDefKindVoidKind).WithOptional(true), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 29, 2)}).
							WithArg("mode", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind).WithOptional(true), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 32, 2), DefaultValue: dagger.JSON("\"dev\"")}).
							WithArg("ghToken", dag.TypeDef().WithKind(dagger.TypeDefKindVoidKind).WithOptional(true).WithOptional(true), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 34, 2)}))), nil
	default:
		return nil, fmt.Errorf("unknown object %s", parentName)
	}
}
